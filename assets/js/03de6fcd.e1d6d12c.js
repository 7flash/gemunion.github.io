"use strict";(self.webpackChunkgemunion_github_io=self.webpackChunkgemunion_github_io||[]).push([[4296],{2982:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var t=a(4848),r=a(8453);const s={hide_table_of_contents:!0,sidebar_position:8},i="Wrapper",o={id:"mechanics-marketing/wrapper/wrapper",title:"Wrapper",description:'The main idea of the Wrapper mechanic is that it can wrap an array of assets into a single token. The Wrap token represents all of the assets that were wrapped, and can be transferred to anyone in a single transfer. When a user wants to unwrap the Wrap token, they can call the "unpack" function and pass the token ID of the Wrap token. This will transfer all of the wrapped tokens back to the owner\'s address, and the Wrap token will be burned.',source:"@site/admin/mechanics-marketing/wrapper/wrapper.md",sourceDirName:"mechanics-marketing/wrapper",slug:"/mechanics-marketing/wrapper/",permalink:"/admin/mechanics-marketing/wrapper/",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{hide_table_of_contents:!0,sidebar_position:8},sidebar:"defaultSidebar",previous:{title:"Token",permalink:"/admin/mechanics-marketing/mystery/token"},next:{title:"Gaming Mechanics",permalink:"/admin/mechanics-gaming/"}},c={},h=[];function d(e){const n={a:"a",em:"em",h1:"h1",p:"p",strong:"strong",...(0,r.RP)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"wrapper",children:"Wrapper"}),"\n",(0,t.jsxs)(n.p,{children:["The main idea of the ",(0,t.jsx)(n.strong,{children:"Wrapper"})," mechanic is that it can ",(0,t.jsxs)(n.strong,{children:["wrap an array of ",(0,t.jsx)(n.a,{href:"/admin/miscellaneous/asset/",children:"assets"})]})," into a single token. The ",(0,t.jsx)(n.strong,{children:"Wrap token"})," represents all of the ",(0,t.jsx)(n.a,{href:"/admin/miscellaneous/asset/",children:"assets"}),' that were wrapped, and can be transferred to anyone in a single transfer. When a user wants to unwrap the Wrap token, they can call the "',(0,t.jsx)(n.strong,{children:"unpack"}),'" function and pass the ',(0,t.jsx)(n.strong,{children:"token ID"})," of the Wrap token. This will transfer all of the wrapped tokens back to the owner's address, and the ",(0,t.jsx)(n.em,{children:"Wrap token"})," will be ",(0,t.jsx)(n.strong,{children:"burned"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To wrap tokens the user needs to provide an ",(0,t.jsxs)(n.strong,{children:["array of ",(0,t.jsx)(n.a,{href:"/admin/miscellaneous/asset/",children:"assets"})]})," representing the tokens that should be wrapped, as well as an ",(0,t.jsx)(n.strong,{children:"account address"})," that will receive the Wrap token. The Wrapper mechanic uses the ",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.a,{href:"/admin/category/exchange/",children:"Transfer"})," functionality"]})," to receive an ",(0,t.jsxs)(n.strong,{children:["array of ",(0,t.jsx)(n.a,{href:"/admin/miscellaneous/asset/",children:"assets"})]})," from the ",(0,t.jsx)(n.strong,{children:"sender's account address"}),". The received assets are then stored in the ",(0,t.jsx)(n.strong,{children:"contract address"})," of the created Wrap token. When the Wrap token is unwrapped, the Wrapper mechanic retrieves the stored array of assets and uses it to transfer the wrapped tokens back to the owner's account address."]})]})}function p(e={}){const{wrapper:n}={...(0,r.RP)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{RP:()=>s});var t=a(6540);const r=t.createContext({});function s(e){const n=t.useContext(r);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);